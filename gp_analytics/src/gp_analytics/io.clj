(ns gp-analytics.io
  "Created by Regina Deri
   Functions for handling various types of IO."
  (:require [clojure.string :as string]
            [clojure.edn :as edn]))


;;#######################################################
;;Functions for generational data input from gpstat files
;;#######################################################

(defn gpstat-split
  "Input: the raw data of a gpstat (EDN) file generated by Propeller for measuring efficiency.
   Output: a list of strings which are the individual entries in the gpstat file."
  [gpstat-raw]
  ;;TODO: currently you need to drop last as it's an \n character appended by "}"
  ;;Should find a more elegant way
  ;(drop-last
   (map #(when-not (string/blank? %) (str % "}")) ;add parentheses dropped by split
        (string/split gpstat-raw #"}")));)

(defn serialize-read
  "Input: path of gpstat file
   Output: the serialized map of entries stored in the gpstat file (EDN format)"
  [file-path]
  (let [raw (slurp file-path)]
    (map edn/read-string
         (gpstat-split raw))))


;;###############################################
;;Functions for output of final statistics in EDN
;;###############################################

(defn prettyprint-stats
  "Formats statistics generated it gp-analytics.core to be human-readable."
  [s]
  (let [keys '(":generations-count" ":total-runtimes" ":average-runtimes" ":improvement-percentage"
                                    ":max-avg-runtime" ":min-avg-runtime" ":change-ratio"
                                    ":change-percentage" ":improvement-ratio" ":aggregate-improvement-ratio"
                                    ":aggregate-total-runtime" ":aggregate-average-runtimes" ":aggregate-max-runtime"
                                    ":aggregate-min-runtime" ":aggregate-change-ratio")]
    (loop [cnt 0
           curr-str s]
      (if (= cnt (count keys))
        curr-str
        (let [curr-key (nth keys cnt)
              replacement (str "\n" curr-key)]
          (recur (inc cnt)
                 (string/replace curr-str curr-key replacement)))))))

(defn serialize-save
  "Saves a value in an EDN format."
  [file-path out-data]
  (spit file-path (prettyprint-stats (pr-str out-data)) :append true))


;;############################################
;;Functions for CSV output of final statistics
;;############################################


(defn seq-2d?
  "Checks whether a sequence is at least truly two-dimensional, that is,
   all of its elements are sequences (not digits, maps, etc.) themselves."
  [a]
  (if (some #(not (sequential? %)) a) 
    false 
    true))

(defn create-csv
  "Creates an empty CSV file (overwrites if it already exists at path)"
  [out-file]
  (spit out-file ""))

(defn format-csv-row
  "Takes a sequence containing all the cells of a single row of csv and returns a string
   that can be directly written in a csv format."
  [cells]
  (let [str-cells (map pr-str cells)]
    (str (string/join "," str-cells) "\n")))

(defn csv-add-nth
  "Takes nth element from every sequence in the parameter values and saves it as a single row
   in the specified csv file"
  [out-file values n]
  (let [nth-row-values (if (seq-2d? values)
                         (map #(nth % n) values)
                         (nth values n))
        output-text (format-csv-row nth-row-values)]
    (spit out-file output-text :append true)))


(defn get-key
  "Gets the value of a nested key from a two-level nested hashmap"
  [statistics key]
  (let [first-key (keyword (first key))
        second-key (keyword (second key))
        first-val (get statistics first-key)]
    (map #(get % second-key) first-val)))

(defn get-keys
  "Gets the value of multiple nested key from a two-level nested hashmap"
  [statistics key-list]
  (map #(get-key statistics %) key-list))

(defn keys-to-csv
  "Saves the values of inputted keys (can be nested) from statistics."
  [out-file statistics key-list]
  (let [values (get-keys statistics key-list)
        row-cnt (count (first values))]; each row should contain a constant number of cells  
    (loop [curr-row 0]
      (when (> row-cnt curr-row )
        (csv-add-nth out-file values curr-row)
        (recur (inc curr-row))))))